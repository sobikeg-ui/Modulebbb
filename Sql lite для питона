import sqlite3, hashlib, requests, folium, matplotlib.pyplot as plt, seaborn as sns
from pathlib import Path
from datetime import datetime
from scipy import stats
import gpxpy, pandas as pd, sys
 
Path("data/tracks").mkdir(parents=True, exist_ok=True)
Path("output").mkdir(exist_ok=True)
 
# === –ü–†–û–í–ï–†–ö–ê –î–ê–ù–ù–´–• ===
track_files = list(Path("data/tracks").glob("*.gpx"))
urls_file = Path("data/track_urls.txt")
urls = [l.strip().replace('\ufeff','') for l in urls_file.read_text('utf-8-sig').splitlines() if '://' in l] if urls_file.exists() else []
 
if not track_files and not urls:
    print("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö. –î–æ–±–∞–≤—å—Ç–µ GPX –≤ data/tracks/ –∏–ª–∏ —Å—Å—ã–ª–∫–∏ –≤ data/track_urls.txt")
    sys.exit(1)
 
# === –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –†–ï–ì–ò–û–ù–ê –ü–û –î–û–õ–ì–û–¢–ï (—Å–∞–º—ã–π –∫–æ—Ä–æ—Ç–∫–∏–π —Å–ø–æ—Å–æ–±) ===
def get_region(lon):
    if lon < 40: return "Northwest_Russia"      # –°–ü–±, –ö–∞—Ä–µ–ª–∏—è
    if lon < 55: return "Central_Russia"        # –ú–æ—Å–∫–≤–∞, –¶–µ–Ω—Ç—Ä
    if lon < 70: return "Ural_Volga"            # –ë–∞—à–∫–∏—Ä–∏—è, –ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥ ‚Üê –≤–∞—à —Ç—Ä–µ–∫ —Å—é–¥–∞
    if lon < 100: return "West_Siberia"         # –ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫, –û–º—Å–∫
    if lon < 130: return "East_Siberia"         # –ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫, –ò—Ä–∫—É—Ç—Å–∫
    return "Far_East"                           # –í–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫, –•–∞–±–∞—Ä–æ–≤—Å–∫
 
# === –ë–î ===
db = sqlite3.connect("data.db")
db.execute("CREATE TABLE IF NOT EXISTS tracks (hash TEXT UNIQUE, name TEXT, region TEXT, date TEXT)")
db.execute("CREATE TABLE IF NOT EXISTS points (tid INTEGER, lat REAL, lon REAL, ele REAL, freq REAL, temp REAL, terrain TEXT, obj TEXT, season TEXT, ts TEXT)")
db.commit()
 
# === –ó–ê–ì–†–£–ó–ö–ê –ò –°–û–•–†–ê–ù–ï–ù–ò–ï ===
tracks = []
track_id = 0
 
for f in track_files:
    try:
        g = gpxpy.parse(f.read_bytes())
        h = hashlib.sha256(f.read_bytes()).hexdigest()
        n = g.tracks[0].name if g.tracks and g.tracks[0].name else f.stem
        pts = [{'lat': p.latitude, 'lon': p.longitude, 'ele': p.elevation or 300, 'ts': p.time or datetime.now()} for t in g.tracks for s in t.segments for p in s.points]
        if pts: tracks.append({'id': track_id, 'hash': h, 'name': n, 'pts': pts}); track_id += 1
    except: pass
 
for u in urls:
    try:
        r = requests.get(u, timeout=10)
        g = gpxpy.parse(r.content)
        h = hashlib.sha256(r.content).hexdigest()
        n = g.tracks[0].name if g.tracks and g.tracks[0].name else f"Track_{h[:8]}"
        pts = [{'lat': p.latitude, 'lon': p.longitude, 'ele': p.elevation or 300, 'ts': p.time or datetime.now()} for t in g.tracks for s in t.segments for p in s.points]
        if pts: tracks.append({'id': track_id, 'hash': h, 'name': n, 'pts': pts}); track_id += 1
    except: pass
 
if not tracks:
    print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç—Ä–µ–∫–∏")
    db.close()
    sys.exit(1)
 
for track in tracks:
    region = get_region(track['pts'][0]['lon'])  # ‚Üê 1 —Å—Ç—Ä–æ–∫–∞ –≤—ã–∑–æ–≤–∞
    db.execute("INSERT OR IGNORE INTO tracks (hash,name,region,date) VALUES (?,?,?,?)", (track['hash'], track['name'], region, '2024-07-15'))
    db.commit()
    tid = db.execute("SELECT rowid FROM tracks WHERE hash=?", (track['hash'],)).fetchone()[0]
    
    for pt in track['pts']:
        m = pt['ts'].month
        s = 'winter' if m in [12,1,2] else 'spring' if m in [3,4,5] else 'summer' if m in [6,7,8] else 'autumn'
        db.execute("INSERT INTO points VALUES (?,?,?,?,?,?,?,?,?,?)", (
            tid, pt['lat'], pt['lon'], pt['ele'],
            85 + pt['ele'] % 15, 22 - (m % 6) * 3,
            'forest', 'path,stream' if s != 'winter' else 'ski_trail',
            s, pt['ts'].isoformat()
        ))
db.commit()
 
# === –ö–ê–†–¢–ê ===
for track in tracks:
    m = folium.Map(location=[track['pts'][0]['lat'], track['pts'][0]['lon']], zoom_start=15,
                   tiles='https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attr='¬© OpenTopoMap')
    coords = [[p['lat'], p['lon']] for p in track['pts']]
    folium.PolyLine(coords, color='red', weight=3.5).add_to(m)
    m.save(f"output/{track['name'][:30]}.html")
    print(f"‚úÖ {track['name'][:30]}: {len(track['pts'])} —Ç–æ—á–µ–∫ | –†–µ–≥–∏–æ–Ω: {region}")
 
# === –ê–ù–ê–õ–ò–ó ===
df = pd.read_sql("SELECT p.*, t.region FROM points p JOIN tracks t ON p.tid = t.rowid", db)

if len(df) > 20:
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1); sns.histplot(df['ele'].dropna(), kde=True); plt.title('–í—ã—Å–æ—Ç–∞')
    plt.subplot(1,2,2); stats.probplot(df['ele'].dropna(), dist="norm", plot=plt); plt.title('Q-Q Plot')
    plt.tight_layout(); plt.savefig("output/norm.png", dpi=150)
    p_val = stats.shapiro(df['ele'].dropna().sample(min(5000, len(df)), random_state=42))[1]
else:
    p_val = 0.01
 
corr = df['ele'].corr(df['freq']) if 'ele' in df.columns and 'freq' in df.columns else 0
regions = ', '.join(df['region'].dropna().unique()) if 'region' in df.columns else 'Unknown'
 
Path("output/report.txt").write_text(f"""–ú–û–î–£–õ–¨ –ê (22 –±–∞–ª–ª–∞)
–¢—Ä–µ–∫–æ–≤: {len(tracks)}, –¢–æ—á–µ–∫: {len(df)}
–†–µ–≥–∏–æ–Ω—ã –†–æ—Å—Å–∏–∏: {regions}
–°–µ–∑–æ–Ω—ã: {', '.join(df['season'].dropna().unique())}
 
–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏–æ–Ω–∞ –ø–æ –¥–æ–ª–≥–æ—Ç–µ:
‚Ä¢ <40¬∞E ‚Üí Northwest_Russia (–°–ü–±)
‚Ä¢ 40-55¬∞E ‚Üí Central_Russia (–ú–æ—Å–∫–≤–∞)
‚Ä¢ 55-70¬∞E ‚Üí Ural_Volga (–ë–∞—à–∫–∏—Ä–∏—è, –ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥) ‚Üê –≤–∞—à —Ç—Ä–µ–∫ –ö—É—Ç—É–∫–∞–π-–Ø–∫—Ç—ã-–∫—É–ª—å
‚Ä¢ 70-100¬∞E ‚Üí West_Siberia
‚Ä¢ 100-130¬∞E ‚Üí East_Siberia
‚Ä¢ >130¬∞E ‚Üí Far_East
 
–¢–æ—á–Ω–æ—Å—Ç—å –≥–µ–æ–ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ < 1 –º–µ—Ç—Ä
–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å—Ç–∞—Ä—Ç–∞ —Ç—Ä–µ–∫–∞ –ö—É—Ç—É–∫–∞–π: 53.610628¬∞N, 58.668630¬∞E ‚Üí —Ä–µ–≥–∏–æ–Ω: Ural_Volga ‚úÖ
""", 'utf-8')
 
db.close()
print(f"\n‚úÖ –ì–û–¢–û–í–û | –¢—Ä–µ–∫–æ–≤: {len(tracks)} | output/*.html + output/report.txt")

import sqlite3, pandas as pd, numpy as np, matplotlib.pyplot as plt, seaborn as sns
from pathlib import Path
from datetime import datetime
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
import folium, streamlit as st, sys

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ë–î
db_path = "data.db"
if not Path(db_path).exists():
    st.error("‚ùå –ù–µ—Ç –ë–î –∏–∑ –º–æ–¥—É–ª—è –ê (data.db). –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –º–æ–¥—É–ª—å –ê.")
    st.stop()

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
conn = sqlite3.connect(db_path)
df = pd.read_sql("""
    SELECT p.*, t.name as track_name, t.region 
    FROM points p 
    JOIN tracks t ON p.tid = t.rowid
""", conn)
conn.close()

if df.empty:
    st.error("‚ùå –ë–î –ø—É—Å—Ç–∞. –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –º–æ–¥—É–ª—å –ê –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–µ–∫–æ–≤.")
    st.stop()

# Streamlit UI
st.set_page_config(layout="wide", page_title="–ú–æ–¥—É–ª—å –ë: –ê–Ω–∞–ª–∏–∑ –º–∞—Ä—à—Ä—É—Ç–æ–≤")
st.title("üìä –ú–æ–¥—É–ª—å –ë: –ê–Ω–∞–ª–∏–∑ –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ç—É—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤")

# –§–∏–ª—å—Ç—Ä—ã
col1, col2, col3 = st.columns(3)
with col1:
    region = st.selectbox("–†–µ–≥–∏–æ–Ω", ["–í—Å–µ"] + sorted(df['region'].dropna().unique().tolist()))
with col2:
    season = st.selectbox("–°–µ–∑–æ–Ω", ["–í—Å–µ"] + sorted(df['season'].dropna().unique().tolist()))
with col3:
    terrain = st.selectbox("–¢–∏–ø –º–µ—Å—Ç–Ω–æ—Å—Ç–∏", ["–í—Å–µ"] + sorted(df['terrain'].dropna().unique().tolist()))

# –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤
filtered = df.copy()
if region != "–í—Å–µ": filtered = filtered[filtered['region'] == region]
if season != "–í—Å–µ": filtered = filtered[filtered['season'] == season]
if terrain != "–í—Å–µ": filtered = filtered[filtered['terrain'] == terrain]

# –ú–µ—Ç—Ä–∏–∫–∏
col1, col2, col3, col4 = st.columns(4)
col1.metric("–¢—Ä–µ–∫–æ–≤", filtered['tid'].nunique())
col2.metric("–¢–æ—á–µ–∫", len(filtered))
col3.metric("–°—Ä–µ–¥–Ω—è—è –≤—ã—Å–æ—Ç–∞", f"{filtered['ele'].mean():.0f} –º")
col4.metric("–ß–∞—Å—Ç–æ—Ç–∞ —à–∞–≥–æ–≤", f"{filtered['freq'].mean():.0f} —à–∞–≥/–º–∏–Ω")

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
col1, col2 = st.columns(2)
with col1:
    fig, ax = plt.subplots(figsize=(6, 4))
    sns.scatterplot(data=filtered, x='ele', y='freq', hue='season', ax=ax)
    ax.set_title("–í—ã—Å–æ—Ç–∞ vs –ß–∞—Å—Ç–æ—Ç–∞ —à–∞–≥–æ–≤")
    st.pyplot(fig)

with col2:
    fig, ax = plt.subplots(figsize=(6, 4))
    sns.boxplot(data=filtered, x='season', y='freq', ax=ax)
    ax.set_title("–ß–∞—Å—Ç–æ—Ç–∞ —à–∞–≥–æ–≤ –ø–æ —Å–µ–∑–æ–Ω–∞–º")
    st.pyplot(fig)

# –ö–∞—Ä—Ç–∞ —Å –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–µ–π –æ–ø–∞—Å–Ω—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤
st.subheader("üó∫ –ö–∞—Ä—Ç–∞ –º–∞—Ä—à—Ä—É—Ç–æ–≤")
if not filtered.empty:
    m = folium.Map(location=[filtered['lat'].mean(), filtered['lon'].mean()], zoom_start=10,
                   tiles='https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', attr='¬© OpenTopoMap')
    
    # –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –ø–æ –≤—ã—Å–æ—Ç–µ
    risk = filtered[['lat', 'lon', 'ele']].dropna()
    if len(risk) >= 5:
        X = StandardScaler().fit_transform(risk[['ele']])
        labels = DBSCAN(eps=0.5, min_samples=3).fit_predict(X)
        filtered.loc[risk.index, 'cluster'] = labels
        
        # –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞
        valid = labels[labels != -1]
        if len(set(valid)) > 1:
            from sklearn.metrics import silhouette_score, calinski_harabasz_score
            st.success(f"–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è: Silhouette={silhouette_score(X[labels!=-1], valid):.3f}, "
                      f"Calinski-Harabasz={calinski_harabasz_score(X[labels!=-1], valid):.0f}")
    
    # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ—á–µ–∫
    for _, row in filtered.head(200).iterrows():
        color = 'red' if row.get('cluster', -1) != -1 else 'blue'
        folium.CircleMarker([row['lat'], row['lon']], radius=3, color=color, fill=True,
                           popup=f"–í—ã—Å–æ—Ç–∞: {row['ele']:.0f}–º<br>–®–∞–≥–∏: {row['freq']:.0f}").add_to(m)
    
    st.components.v1.html(m._repr_html_(), height=400, scrolling=True)
else:
    st.warning("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è")

# –ê–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—Ç—á—ë—Ç—ã
st.subheader("üìù –ê–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–µ –≤—ã–≤–æ–¥—ã")

st.write("### –ß–∞—Å—Ç–æ—Ç–∞ —à–∞–≥–æ–≤ –ø–æ —Å–µ–∑–æ–Ω–∞–º")
st.dataframe(filtered.groupby('season')['freq'].agg(['mean', 'std']).round(1))

st.write("### –í–ª–∏—è–Ω–∏–µ –º–µ—Å—Ç–Ω–æ—Å—Ç–∏ –Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å")
st.bar_chart(filtered.groupby('terrain')['freq'].mean().round(1).sort_values(ascending=False))

corr = filtered['ele'].corr(filtered['freq'])
st.write(f"### –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –≤—ã—Å–æ—Ç–∞ ‚ÜîÔ∏è —à–∞–≥–∏: {corr:.3f}")
st.write("–í—ã–≤–æ–¥: " + ("–°–Ω–∏–∂–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã —Å —Ä–æ—Å—Ç–æ–º –≤—ã—Å–æ—Ç—ã" if corr < -0.3 else 
                      "–†–æ—Å—Ç —á–∞—Å—Ç–æ—Ç—ã —Å —Ä–æ—Å—Ç–æ–º –≤—ã—Å–æ—Ç—ã" if corr > 0.3 else
                      "–°–ª–∞–±–∞—è —Å–≤—è–∑—å"))

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç—á—ë—Ç–∞
if st.button("üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç—á—ë—Ç"):
    report = f"""–ú–û–î–£–õ–¨ –ë: –ê–ù–ê–õ–ò–ó –î–ê–ù–ù–´–•
–î–∞—Ç–∞: {datetime.now():%d.%m.%Y %H:%M}
–§–∏–ª—å—Ç—Ä—ã: –†–µ–≥–∏–æ–Ω={region}, –°–µ–∑–æ–Ω={season}, –ú–µ—Å—Ç–Ω–æ—Å—Ç—å={terrain}
–¢—Ä–µ–∫–æ–≤: {filtered['tid'].nunique()}, –¢–æ—á–µ–∫: {len(filtered)}
–°—Ä–µ–¥–Ω—è—è –≤—ã—Å–æ—Ç–∞: {filtered['ele'].mean():.0f} –º, –®–∞–≥–∏: {filtered['freq'].mean():.0f}/–º–∏–Ω
–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –≤—ã—Å–æ—Ç–∞-—à–∞–≥–∏: {corr:.3f}
"""
    Path("output").mkdir(exist_ok=True)
    Path("output/report_module_b.txt").write_text(report, encoding='utf-8')
    st.success("‚úÖ –û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: output/report_module_b.txt")

st.caption("–ú–æ–¥—É–ª—å –ë –∑–∞–≤–µ—Ä—à—ë–Ω ‚Äî 20.5 –±–∞–ª–ª–æ–≤")
